// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: snapshot_files.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSnapshotFile = `-- name: CreateSnapshotFile :one

INSERT INTO snapshot_files (snapshot_id, file_path, file_size, domain, indexed, skip_reason)
VALUES ($1, $2, $3, $5, $4, $6)
RETURNING id, snapshot_id, file_path, file_size, domain, indexed, skip_reason, created_at
`

type CreateSnapshotFileParams struct {
	SnapshotID pgtype.UUID `json:"snapshot_id"`
	FilePath   string      `json:"file_path"`
	FileSize   int64       `json:"file_size"`
	Indexed    bool        `json:"indexed"`
	Domain     pgtype.Text `json:"domain"`
	SkipReason pgtype.Text `json:"skip_reason"`
}

// Phase 2タスク7: カバレッジマップ構築 - snapshot_files操作
func (q *Queries) CreateSnapshotFile(ctx context.Context, arg CreateSnapshotFileParams) (SnapshotFile, error) {
	row := q.db.QueryRow(ctx, createSnapshotFile,
		arg.SnapshotID,
		arg.FilePath,
		arg.FileSize,
		arg.Indexed,
		arg.Domain,
		arg.SkipReason,
	)
	var i SnapshotFile
	err := row.Scan(
		&i.ID,
		&i.SnapshotID,
		&i.FilePath,
		&i.FileSize,
		&i.Domain,
		&i.Indexed,
		&i.SkipReason,
		&i.CreatedAt,
	)
	return i, err
}

const getDomainCoverageStats = `-- name: GetDomainCoverageStats :many
SELECT
    COALESCE(sf.domain, 'unknown') AS domain,
    COUNT(sf.id)::bigint AS total_files,
    SUM(CASE WHEN sf.indexed THEN 1 ELSE 0 END)::bigint AS indexed_files,
    COALESCE(SUM(chunk_counts.chunk_count), 0)::bigint AS indexed_chunks,
    ROUND(
        CASE
            WHEN COUNT(sf.id) > 0 THEN
                SUM(CASE WHEN sf.indexed THEN 1 ELSE 0 END)::numeric / COUNT(sf.id) * 100
            ELSE 0
        END,
        2
    )::numeric AS coverage_rate,
    COALESCE(AVG(chunk_stats.avg_comment_ratio), 0.0)::numeric AS avg_comment_ratio,
    COALESCE(AVG(chunk_stats.avg_complexity), 0.0)::numeric AS avg_complexity
FROM snapshot_files sf
LEFT JOIN files f ON sf.snapshot_id = f.snapshot_id AND sf.file_path = f.path
LEFT JOIN (
    SELECT file_id, COUNT(*) AS chunk_count
    FROM chunks
    GROUP BY file_id
) chunk_counts ON f.id = chunk_counts.file_id
LEFT JOIN (
    SELECT
        c.file_id,
        AVG(COALESCE(c.comment_ratio, 0.0)) AS avg_comment_ratio,
        AVG(COALESCE(c.cyclomatic_complexity, 0)) AS avg_complexity
    FROM chunks c
    GROUP BY c.file_id
) chunk_stats ON f.id = chunk_stats.file_id
WHERE sf.snapshot_id = $1
GROUP BY COALESCE(sf.domain, 'unknown')
ORDER BY COALESCE(sf.domain, 'unknown')
`

type GetDomainCoverageStatsRow struct {
	Domain          string         `json:"domain"`
	TotalFiles      int64          `json:"total_files"`
	IndexedFiles    int64          `json:"indexed_files"`
	IndexedChunks   int64          `json:"indexed_chunks"`
	CoverageRate    pgtype.Numeric `json:"coverage_rate"`
	AvgCommentRatio pgtype.Numeric `json:"avg_comment_ratio"`
	AvgComplexity   pgtype.Numeric `json:"avg_complexity"`
}

func (q *Queries) GetDomainCoverageStats(ctx context.Context, snapshotID pgtype.UUID) ([]GetDomainCoverageStatsRow, error) {
	rows, err := q.db.Query(ctx, getDomainCoverageStats, snapshotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDomainCoverageStatsRow{}
	for rows.Next() {
		var i GetDomainCoverageStatsRow
		if err := rows.Scan(
			&i.Domain,
			&i.TotalFiles,
			&i.IndexedFiles,
			&i.IndexedChunks,
			&i.CoverageRate,
			&i.AvgCommentRatio,
			&i.AvgComplexity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnapshotFilesBySnapshot = `-- name: GetSnapshotFilesBySnapshot :many
SELECT id, snapshot_id, file_path, file_size, domain, indexed, skip_reason, created_at FROM snapshot_files
WHERE snapshot_id = $1
ORDER BY file_path
`

func (q *Queries) GetSnapshotFilesBySnapshot(ctx context.Context, snapshotID pgtype.UUID) ([]SnapshotFile, error) {
	rows, err := q.db.Query(ctx, getSnapshotFilesBySnapshot, snapshotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SnapshotFile{}
	for rows.Next() {
		var i SnapshotFile
		if err := rows.Scan(
			&i.ID,
			&i.SnapshotID,
			&i.FilePath,
			&i.FileSize,
			&i.Domain,
			&i.Indexed,
			&i.SkipReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnindexedImportantFiles = `-- name: GetUnindexedImportantFiles :many
SELECT file_path
FROM snapshot_files
WHERE snapshot_id = $1
AND indexed = false
AND (
    file_path ILIKE '%README.md'
    OR file_path ILIKE '%/docs/adr/%'
    OR file_path ILIKE '%/docs/design/%'
    OR file_path ILIKE '%/docs/decisions/%'
    OR file_path IN ('package.json', 'go.mod', 'Dockerfile', 'docker-compose.yml')
)
ORDER BY file_path
`

func (q *Queries) GetUnindexedImportantFiles(ctx context.Context, snapshotID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getUnindexedImportantFiles, snapshotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var file_path string
		if err := rows.Scan(&file_path); err != nil {
			return nil, err
		}
		items = append(items, file_path)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSnapshotFileIndexed = `-- name: UpdateSnapshotFileIndexed :exec
UPDATE snapshot_files
SET indexed = $3
WHERE snapshot_id = $1 AND file_path = $2
`

type UpdateSnapshotFileIndexedParams struct {
	SnapshotID pgtype.UUID `json:"snapshot_id"`
	FilePath   string      `json:"file_path"`
	Indexed    bool        `json:"indexed"`
}

func (q *Queries) UpdateSnapshotFileIndexed(ctx context.Context, arg UpdateSnapshotFileIndexedParams) error {
	_, err := q.db.Exec(ctx, updateSnapshotFileIndexed, arg.SnapshotID, arg.FilePath, arg.Indexed)
	return err
}
