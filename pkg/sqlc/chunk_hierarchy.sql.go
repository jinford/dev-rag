// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chunk_hierarchy.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addChunkRelation = `-- name: AddChunkRelation :exec
INSERT INTO chunk_hierarchy (parent_chunk_id, child_chunk_id, ordinal)
VALUES ($1, $2, $3)
`

type AddChunkRelationParams struct {
	ParentChunkID pgtype.UUID `json:"parent_chunk_id"`
	ChildChunkID  pgtype.UUID `json:"child_chunk_id"`
	Ordinal       int32       `json:"ordinal"`
}

func (q *Queries) AddChunkRelation(ctx context.Context, arg AddChunkRelationParams) error {
	_, err := q.db.Exec(ctx, addChunkRelation, arg.ParentChunkID, arg.ChildChunkID, arg.Ordinal)
	return err
}

const countChildChunks = `-- name: CountChildChunks :one
SELECT COUNT(*) AS child_count
FROM chunk_hierarchy
WHERE parent_chunk_id = $1
`

func (q *Queries) CountChildChunks(ctx context.Context, parentChunkID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChildChunks, parentChunkID)
	var child_count int64
	err := row.Scan(&child_count)
	return child_count, err
}

const deleteChunkHierarchyByChild = `-- name: DeleteChunkHierarchyByChild :exec
DELETE FROM chunk_hierarchy
WHERE child_chunk_id = $1
`

func (q *Queries) DeleteChunkHierarchyByChild(ctx context.Context, childChunkID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChunkHierarchyByChild, childChunkID)
	return err
}

const deleteChunkHierarchyByParent = `-- name: DeleteChunkHierarchyByParent :exec
DELETE FROM chunk_hierarchy
WHERE parent_chunk_id = $1
`

func (q *Queries) DeleteChunkHierarchyByParent(ctx context.Context, parentChunkID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChunkHierarchyByParent, parentChunkID)
	return err
}

const getChildChunkIDs = `-- name: GetChildChunkIDs :many
SELECT child_chunk_id
FROM chunk_hierarchy
WHERE parent_chunk_id = $1
ORDER BY ordinal
`

func (q *Queries) GetChildChunkIDs(ctx context.Context, parentChunkID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getChildChunkIDs, parentChunkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var child_chunk_id pgtype.UUID
		if err := rows.Scan(&child_chunk_id); err != nil {
			return nil, err
		}
		items = append(items, child_chunk_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChildChunks = `-- name: GetChildChunks :many
SELECT c.id, c.file_id, c.ordinal, c.start_line, c.end_line, c.content, c.content_hash, c.token_count, c.chunk_type, c.chunk_name, c.parent_name, c.signature, c.doc_comment, c.imports, c.calls, c.lines_of_code, c.comment_ratio, c.cyclomatic_complexity, c.embedding_context, c.level, c.importance_score, c.standard_imports, c.external_imports, c.internal_calls, c.external_calls, c.type_dependencies, c.source_snapshot_id, c.git_commit_hash, c.author, c.updated_at, c.indexed_at, c.file_version, c.is_latest, c.chunk_key, c.created_at
FROM chunks c
INNER JOIN chunk_hierarchy ch ON c.id = ch.child_chunk_id
WHERE ch.parent_chunk_id = $1
ORDER BY ch.ordinal
`

func (q *Queries) GetChildChunks(ctx context.Context, parentChunkID pgtype.UUID) ([]Chunk, error) {
	rows, err := q.db.Query(ctx, getChildChunks, parentChunkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chunk{}
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.Ordinal,
			&i.StartLine,
			&i.EndLine,
			&i.Content,
			&i.ContentHash,
			&i.TokenCount,
			&i.ChunkType,
			&i.ChunkName,
			&i.ParentName,
			&i.Signature,
			&i.DocComment,
			&i.Imports,
			&i.Calls,
			&i.LinesOfCode,
			&i.CommentRatio,
			&i.CyclomaticComplexity,
			&i.EmbeddingContext,
			&i.Level,
			&i.ImportanceScore,
			&i.StandardImports,
			&i.ExternalImports,
			&i.InternalCalls,
			&i.ExternalCalls,
			&i.TypeDependencies,
			&i.SourceSnapshotID,
			&i.GitCommitHash,
			&i.Author,
			&i.UpdatedAt,
			&i.IndexedAt,
			&i.FileVersion,
			&i.IsLatest,
			&i.ChunkKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParentChunk = `-- name: GetParentChunk :one
SELECT c.id, c.file_id, c.ordinal, c.start_line, c.end_line, c.content, c.content_hash, c.token_count, c.chunk_type, c.chunk_name, c.parent_name, c.signature, c.doc_comment, c.imports, c.calls, c.lines_of_code, c.comment_ratio, c.cyclomatic_complexity, c.embedding_context, c.level, c.importance_score, c.standard_imports, c.external_imports, c.internal_calls, c.external_calls, c.type_dependencies, c.source_snapshot_id, c.git_commit_hash, c.author, c.updated_at, c.indexed_at, c.file_version, c.is_latest, c.chunk_key, c.created_at
FROM chunks c
INNER JOIN chunk_hierarchy ch ON c.id = ch.parent_chunk_id
WHERE ch.child_chunk_id = $1
LIMIT 1
`

func (q *Queries) GetParentChunk(ctx context.Context, childChunkID pgtype.UUID) (Chunk, error) {
	row := q.db.QueryRow(ctx, getParentChunk, childChunkID)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.Ordinal,
		&i.StartLine,
		&i.EndLine,
		&i.Content,
		&i.ContentHash,
		&i.TokenCount,
		&i.ChunkType,
		&i.ChunkName,
		&i.ParentName,
		&i.Signature,
		&i.DocComment,
		&i.Imports,
		&i.Calls,
		&i.LinesOfCode,
		&i.CommentRatio,
		&i.CyclomaticComplexity,
		&i.EmbeddingContext,
		&i.Level,
		&i.ImportanceScore,
		&i.StandardImports,
		&i.ExternalImports,
		&i.InternalCalls,
		&i.ExternalCalls,
		&i.TypeDependencies,
		&i.SourceSnapshotID,
		&i.GitCommitHash,
		&i.Author,
		&i.UpdatedAt,
		&i.IndexedAt,
		&i.FileVersion,
		&i.IsLatest,
		&i.ChunkKey,
		&i.CreatedAt,
	)
	return i, err
}

const getParentChunkID = `-- name: GetParentChunkID :one
SELECT parent_chunk_id
FROM chunk_hierarchy
WHERE child_chunk_id = $1
LIMIT 1
`

func (q *Queries) GetParentChunkID(ctx context.Context, childChunkID pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getParentChunkID, childChunkID)
	var parent_chunk_id pgtype.UUID
	err := row.Scan(&parent_chunk_id)
	return parent_chunk_id, err
}

const hasChildren = `-- name: HasChildren :one
SELECT EXISTS(
    SELECT 1
    FROM chunk_hierarchy
    WHERE parent_chunk_id = $1
) AS has_children
`

func (q *Queries) HasChildren(ctx context.Context, parentChunkID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, hasChildren, parentChunkID)
	var has_children bool
	err := row.Scan(&has_children)
	return has_children, err
}

const hasParent = `-- name: HasParent :one
SELECT EXISTS(
    SELECT 1
    FROM chunk_hierarchy
    WHERE child_chunk_id = $1
) AS has_parent
`

func (q *Queries) HasParent(ctx context.Context, childChunkID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, hasParent, childChunkID)
	var has_parent bool
	err := row.Scan(&has_parent)
	return has_parent, err
}

const removeChunkRelation = `-- name: RemoveChunkRelation :exec
DELETE FROM chunk_hierarchy
WHERE parent_chunk_id = $1 AND child_chunk_id = $2
`

type RemoveChunkRelationParams struct {
	ParentChunkID pgtype.UUID `json:"parent_chunk_id"`
	ChildChunkID  pgtype.UUID `json:"child_chunk_id"`
}

func (q *Queries) RemoveChunkRelation(ctx context.Context, arg RemoveChunkRelationParams) error {
	_, err := q.db.Exec(ctx, removeChunkRelation, arg.ParentChunkID, arg.ChildChunkID)
	return err
}
