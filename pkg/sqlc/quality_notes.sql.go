// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quality_notes.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countQualityNotesBySeverity = `-- name: CountQualityNotesBySeverity :one
SELECT severity, COUNT(*) as count
FROM quality_notes
WHERE status = $1
GROUP BY severity
ORDER BY
    CASE severity
        WHEN 'critical' THEN 1
        WHEN 'high' THEN 2
        WHEN 'medium' THEN 3
        WHEN 'low' THEN 4
    END
`

type CountQualityNotesBySeverityRow struct {
	Severity string `json:"severity"`
	Count    int64  `json:"count"`
}

func (q *Queries) CountQualityNotesBySeverity(ctx context.Context, status string) (CountQualityNotesBySeverityRow, error) {
	row := q.db.QueryRow(ctx, countQualityNotesBySeverity, status)
	var i CountQualityNotesBySeverityRow
	err := row.Scan(&i.Severity, &i.Count)
	return i, err
}

const createQualityNote = `-- name: CreateQualityNote :one
INSERT INTO quality_notes (note_id, severity, note_text, linked_files, linked_chunks, reviewer, status)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, note_id, severity, note_text, linked_files, linked_chunks, reviewer, status, created_at, resolved_at
`

type CreateQualityNoteParams struct {
	NoteID       string `json:"note_id"`
	Severity     string `json:"severity"`
	NoteText     string `json:"note_text"`
	LinkedFiles  []byte `json:"linked_files"`
	LinkedChunks []byte `json:"linked_chunks"`
	Reviewer     string `json:"reviewer"`
	Status       string `json:"status"`
}

func (q *Queries) CreateQualityNote(ctx context.Context, arg CreateQualityNoteParams) (QualityNote, error) {
	row := q.db.QueryRow(ctx, createQualityNote,
		arg.NoteID,
		arg.Severity,
		arg.NoteText,
		arg.LinkedFiles,
		arg.LinkedChunks,
		arg.Reviewer,
		arg.Status,
	)
	var i QualityNote
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.Severity,
		&i.NoteText,
		&i.LinkedFiles,
		&i.LinkedChunks,
		&i.Reviewer,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const deleteQualityNote = `-- name: DeleteQualityNote :exec
DELETE FROM quality_notes
WHERE id = $1
`

func (q *Queries) DeleteQualityNote(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteQualityNote, id)
	return err
}

const getQualityNote = `-- name: GetQualityNote :one
SELECT id, note_id, severity, note_text, linked_files, linked_chunks, reviewer, status, created_at, resolved_at FROM quality_notes
WHERE id = $1
`

func (q *Queries) GetQualityNote(ctx context.Context, id pgtype.UUID) (QualityNote, error) {
	row := q.db.QueryRow(ctx, getQualityNote, id)
	var i QualityNote
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.Severity,
		&i.NoteText,
		&i.LinkedFiles,
		&i.LinkedChunks,
		&i.Reviewer,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const getQualityNoteByNoteID = `-- name: GetQualityNoteByNoteID :one
SELECT id, note_id, severity, note_text, linked_files, linked_chunks, reviewer, status, created_at, resolved_at FROM quality_notes
WHERE note_id = $1
`

func (q *Queries) GetQualityNoteByNoteID(ctx context.Context, noteID string) (QualityNote, error) {
	row := q.db.QueryRow(ctx, getQualityNoteByNoteID, noteID)
	var i QualityNote
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.Severity,
		&i.NoteText,
		&i.LinkedFiles,
		&i.LinkedChunks,
		&i.Reviewer,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const getRecentQualityNotes = `-- name: GetRecentQualityNotes :many
SELECT id, note_id, severity, note_text, linked_files, linked_chunks, reviewer, status, created_at, resolved_at FROM quality_notes
WHERE created_at >= NOW() - INTERVAL '7 days'
ORDER BY severity DESC, created_at DESC
`

func (q *Queries) GetRecentQualityNotes(ctx context.Context) ([]QualityNote, error) {
	rows, err := q.db.Query(ctx, getRecentQualityNotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityNote{}
	for rows.Next() {
		var i QualityNote
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.Severity,
			&i.NoteText,
			&i.LinkedFiles,
			&i.LinkedChunks,
			&i.Reviewer,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityNotes = `-- name: ListQualityNotes :many
SELECT id, note_id, severity, note_text, linked_files, linked_chunks, reviewer, status, created_at, resolved_at FROM quality_notes
WHERE
    ($1::text IS NULL OR severity = $1) AND
    ($2::text IS NULL OR status = $2) AND
    ($3::timestamp IS NULL OR created_at >= $3) AND
    ($4::timestamp IS NULL OR created_at <= $4)
ORDER BY created_at DESC
LIMIT COALESCE($5, 100)
`

type ListQualityNotesParams struct {
	Severity   string           `json:"severity"`
	Status     string           `json:"status"`
	StartDate  pgtype.Timestamp `json:"start_date"`
	EndDate    pgtype.Timestamp `json:"end_date"`
	LimitCount interface{}      `json:"limit_count"`
}

func (q *Queries) ListQualityNotes(ctx context.Context, arg ListQualityNotesParams) ([]QualityNote, error) {
	rows, err := q.db.Query(ctx, listQualityNotes,
		arg.Severity,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityNote{}
	for rows.Next() {
		var i QualityNote
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.Severity,
			&i.NoteText,
			&i.LinkedFiles,
			&i.LinkedChunks,
			&i.Reviewer,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityNotesByDateRange = `-- name: ListQualityNotesByDateRange :many
SELECT id, note_id, severity, note_text, linked_files, linked_chunks, reviewer, status, created_at, resolved_at FROM quality_notes
WHERE created_at >= $1 AND created_at <= $2
ORDER BY created_at DESC
`

type ListQualityNotesByDateRangeParams struct {
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	CreatedAt_2 pgtype.Timestamp `json:"created_at_2"`
}

func (q *Queries) ListQualityNotesByDateRange(ctx context.Context, arg ListQualityNotesByDateRangeParams) ([]QualityNote, error) {
	rows, err := q.db.Query(ctx, listQualityNotesByDateRange, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityNote{}
	for rows.Next() {
		var i QualityNote
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.Severity,
			&i.NoteText,
			&i.LinkedFiles,
			&i.LinkedChunks,
			&i.Reviewer,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityNotesBySeverity = `-- name: ListQualityNotesBySeverity :many
SELECT id, note_id, severity, note_text, linked_files, linked_chunks, reviewer, status, created_at, resolved_at FROM quality_notes
WHERE severity = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQualityNotesBySeverity(ctx context.Context, severity string) ([]QualityNote, error) {
	rows, err := q.db.Query(ctx, listQualityNotesBySeverity, severity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityNote{}
	for rows.Next() {
		var i QualityNote
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.Severity,
			&i.NoteText,
			&i.LinkedFiles,
			&i.LinkedChunks,
			&i.Reviewer,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityNotesByStatus = `-- name: ListQualityNotesByStatus :many
SELECT id, note_id, severity, note_text, linked_files, linked_chunks, reviewer, status, created_at, resolved_at FROM quality_notes
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQualityNotesByStatus(ctx context.Context, status string) ([]QualityNote, error) {
	rows, err := q.db.Query(ctx, listQualityNotesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QualityNote{}
	for rows.Next() {
		var i QualityNote
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.Severity,
			&i.NoteText,
			&i.LinkedFiles,
			&i.LinkedChunks,
			&i.Reviewer,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQualityNote = `-- name: UpdateQualityNote :one
UPDATE quality_notes
SET
    note_text = $2,
    linked_files = $3,
    linked_chunks = $4,
    severity = $5
WHERE id = $1
RETURNING id, note_id, severity, note_text, linked_files, linked_chunks, reviewer, status, created_at, resolved_at
`

type UpdateQualityNoteParams struct {
	ID           pgtype.UUID `json:"id"`
	NoteText     string      `json:"note_text"`
	LinkedFiles  []byte      `json:"linked_files"`
	LinkedChunks []byte      `json:"linked_chunks"`
	Severity     string      `json:"severity"`
}

func (q *Queries) UpdateQualityNote(ctx context.Context, arg UpdateQualityNoteParams) (QualityNote, error) {
	row := q.db.QueryRow(ctx, updateQualityNote,
		arg.ID,
		arg.NoteText,
		arg.LinkedFiles,
		arg.LinkedChunks,
		arg.Severity,
	)
	var i QualityNote
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.Severity,
		&i.NoteText,
		&i.LinkedFiles,
		&i.LinkedChunks,
		&i.Reviewer,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const updateQualityNoteStatus = `-- name: UpdateQualityNoteStatus :one
UPDATE quality_notes
SET status = $2, resolved_at = $3
WHERE id = $1
RETURNING id, note_id, severity, note_text, linked_files, linked_chunks, reviewer, status, created_at, resolved_at
`

type UpdateQualityNoteStatusParams struct {
	ID         pgtype.UUID      `json:"id"`
	Status     string           `json:"status"`
	ResolvedAt pgtype.Timestamp `json:"resolved_at"`
}

func (q *Queries) UpdateQualityNoteStatus(ctx context.Context, arg UpdateQualityNoteStatusParams) (QualityNote, error) {
	row := q.db.QueryRow(ctx, updateQualityNoteStatus, arg.ID, arg.Status, arg.ResolvedAt)
	var i QualityNote
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.Severity,
		&i.NoteText,
		&i.LinkedFiles,
		&i.LinkedChunks,
		&i.Reviewer,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}
