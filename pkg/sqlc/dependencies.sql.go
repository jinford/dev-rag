// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dependencies.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDependency = `-- name: CreateDependency :exec
INSERT INTO chunk_dependencies (
    from_chunk_id,
    to_chunk_id,
    dep_type,
    symbol
) VALUES (
    $1, $2, $3, $4
) ON CONFLICT (from_chunk_id, to_chunk_id, dep_type, symbol) DO NOTHING
`

type CreateDependencyParams struct {
	FromChunkID pgtype.UUID `json:"from_chunk_id"`
	ToChunkID   pgtype.UUID `json:"to_chunk_id"`
	DepType     string      `json:"dep_type"`
	Symbol      pgtype.Text `json:"symbol"`
}

func (q *Queries) CreateDependency(ctx context.Context, arg CreateDependencyParams) error {
	_, err := q.db.Exec(ctx, createDependency,
		arg.FromChunkID,
		arg.ToChunkID,
		arg.DepType,
		arg.Symbol,
	)
	return err
}

const deleteDependenciesByChunk = `-- name: DeleteDependenciesByChunk :exec
DELETE FROM chunk_dependencies
WHERE from_chunk_id = $1 OR to_chunk_id = $1
`

func (q *Queries) DeleteDependenciesByChunk(ctx context.Context, fromChunkID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteDependenciesByChunk, fromChunkID)
	return err
}

const getAllDependencies = `-- name: GetAllDependencies :many
SELECT id, from_chunk_id, to_chunk_id, dep_type, symbol, created_at FROM chunk_dependencies
ORDER BY created_at DESC
`

func (q *Queries) GetAllDependencies(ctx context.Context) ([]ChunkDependency, error) {
	rows, err := q.db.Query(ctx, getAllDependencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChunkDependency{}
	for rows.Next() {
		var i ChunkDependency
		if err := rows.Scan(
			&i.ID,
			&i.FromChunkID,
			&i.ToChunkID,
			&i.DepType,
			&i.Symbol,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependenciesByChunk = `-- name: GetDependenciesByChunk :many
SELECT id, from_chunk_id, to_chunk_id, dep_type, symbol, created_at FROM chunk_dependencies
WHERE from_chunk_id = $1
ORDER BY dep_type, symbol
`

func (q *Queries) GetDependenciesByChunk(ctx context.Context, fromChunkID pgtype.UUID) ([]ChunkDependency, error) {
	rows, err := q.db.Query(ctx, getDependenciesByChunk, fromChunkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChunkDependency{}
	for rows.Next() {
		var i ChunkDependency
		if err := rows.Scan(
			&i.ID,
			&i.FromChunkID,
			&i.ToChunkID,
			&i.DepType,
			&i.Symbol,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependenciesByChunkAndType = `-- name: GetDependenciesByChunkAndType :many
SELECT id, from_chunk_id, to_chunk_id, dep_type, symbol, created_at FROM chunk_dependencies
WHERE from_chunk_id = $1 AND dep_type = $2
ORDER BY symbol
`

type GetDependenciesByChunkAndTypeParams struct {
	FromChunkID pgtype.UUID `json:"from_chunk_id"`
	DepType     string      `json:"dep_type"`
}

func (q *Queries) GetDependenciesByChunkAndType(ctx context.Context, arg GetDependenciesByChunkAndTypeParams) ([]ChunkDependency, error) {
	rows, err := q.db.Query(ctx, getDependenciesByChunkAndType, arg.FromChunkID, arg.DepType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChunkDependency{}
	for rows.Next() {
		var i ChunkDependency
		if err := rows.Scan(
			&i.ID,
			&i.FromChunkID,
			&i.ToChunkID,
			&i.DepType,
			&i.Symbol,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependencyCount = `-- name: GetDependencyCount :one
SELECT COUNT(*) FROM chunk_dependencies
WHERE from_chunk_id = $1
`

func (q *Queries) GetDependencyCount(ctx context.Context, fromChunkID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getDependencyCount, fromChunkID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getIncomingDependenciesByChunk = `-- name: GetIncomingDependenciesByChunk :many
SELECT id, from_chunk_id, to_chunk_id, dep_type, symbol, created_at FROM chunk_dependencies
WHERE to_chunk_id = $1
ORDER BY dep_type, symbol
`

func (q *Queries) GetIncomingDependenciesByChunk(ctx context.Context, toChunkID pgtype.UUID) ([]ChunkDependency, error) {
	rows, err := q.db.Query(ctx, getIncomingDependenciesByChunk, toChunkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChunkDependency{}
	for rows.Next() {
		var i ChunkDependency
		if err := rows.Scan(
			&i.ID,
			&i.FromChunkID,
			&i.ToChunkID,
			&i.DepType,
			&i.Symbol,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIncomingDependencyCount = `-- name: GetIncomingDependencyCount :one
SELECT COUNT(*) FROM chunk_dependencies
WHERE to_chunk_id = $1
`

func (q *Queries) GetIncomingDependencyCount(ctx context.Context, toChunkID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getIncomingDependencyCount, toChunkID)
	var count int64
	err := row.Scan(&count)
	return count, err
}
