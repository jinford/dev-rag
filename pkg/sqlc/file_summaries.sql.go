// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: file_summaries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const countFileSummariesBySnapshot = `-- name: CountFileSummariesBySnapshot :one
SELECT COUNT(*)
FROM file_summaries fs
JOIN files f ON fs.file_id = f.id
WHERE f.snapshot_id = $1
`

func (q *Queries) CountFileSummariesBySnapshot(ctx context.Context, snapshotID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countFileSummariesBySnapshot, snapshotID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFileSummary = `-- name: CreateFileSummary :one
INSERT INTO file_summaries (
    file_id,
    summary,
    embedding,
    metadata
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, file_id, summary, embedding, metadata, created_at, updated_at
`

type CreateFileSummaryParams struct {
	FileID    pgtype.UUID        `json:"file_id"`
	Summary   string             `json:"summary"`
	Embedding pgvector_go.Vector `json:"embedding"`
	Metadata  []byte             `json:"metadata"`
}

func (q *Queries) CreateFileSummary(ctx context.Context, arg CreateFileSummaryParams) (FileSummary, error) {
	row := q.db.QueryRow(ctx, createFileSummary,
		arg.FileID,
		arg.Summary,
		arg.Embedding,
		arg.Metadata,
	)
	var i FileSummary
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.Summary,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFileSummariesBySnapshot = `-- name: DeleteFileSummariesBySnapshot :exec
DELETE FROM file_summaries
WHERE file_id IN (
    SELECT id FROM files WHERE snapshot_id = $1
)
`

func (q *Queries) DeleteFileSummariesBySnapshot(ctx context.Context, snapshotID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFileSummariesBySnapshot, snapshotID)
	return err
}

const deleteFileSummaryByFileID = `-- name: DeleteFileSummaryByFileID :exec
DELETE FROM file_summaries
WHERE file_id = $1
`

func (q *Queries) DeleteFileSummaryByFileID(ctx context.Context, fileID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFileSummaryByFileID, fileID)
	return err
}

const getFileSummaryByFileID = `-- name: GetFileSummaryByFileID :one
SELECT id, file_id, summary, embedding, metadata, created_at, updated_at FROM file_summaries
WHERE file_id = $1
`

func (q *Queries) GetFileSummaryByFileID(ctx context.Context, fileID pgtype.UUID) (FileSummary, error) {
	row := q.db.QueryRow(ctx, getFileSummaryByFileID, fileID)
	var i FileSummary
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.Summary,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileSummaryByPath = `-- name: GetFileSummaryByPath :one
SELECT fs.summary
FROM file_summaries fs
JOIN files f ON fs.file_id = f.id
WHERE f.snapshot_id = $1 AND f.path = $2
`

type GetFileSummaryByPathParams struct {
	SnapshotID pgtype.UUID `json:"snapshot_id"`
	Path       string      `json:"path"`
}

func (q *Queries) GetFileSummaryByPath(ctx context.Context, arg GetFileSummaryByPathParams) (string, error) {
	row := q.db.QueryRow(ctx, getFileSummaryByPath, arg.SnapshotID, arg.Path)
	var summary string
	err := row.Scan(&summary)
	return summary, err
}

const listFileSummariesBySnapshot = `-- name: ListFileSummariesBySnapshot :many
SELECT fs.id, fs.file_id, fs.summary, fs.embedding, fs.metadata, fs.created_at, fs.updated_at
FROM file_summaries fs
JOIN files f ON fs.file_id = f.id
WHERE f.snapshot_id = $1
ORDER BY f.path
`

func (q *Queries) ListFileSummariesBySnapshot(ctx context.Context, snapshotID pgtype.UUID) ([]FileSummary, error) {
	rows, err := q.db.Query(ctx, listFileSummariesBySnapshot, snapshotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FileSummary{}
	for rows.Next() {
		var i FileSummary
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.Summary,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFileSummariesByEmbedding = `-- name: SearchFileSummariesByEmbedding :many
SELECT
    fs.id, fs.file_id, fs.summary, fs.embedding, fs.metadata, fs.created_at, fs.updated_at,
    f.path,
    f.language,
    1 - (fs.embedding <=> $1::vector) AS similarity
FROM file_summaries fs
JOIN files f ON fs.file_id = f.id
WHERE f.snapshot_id = $2
ORDER BY fs.embedding <=> $1::vector
LIMIT $3
`

type SearchFileSummariesByEmbeddingParams struct {
	Column1    pgvector_go.Vector `json:"column_1"`
	SnapshotID pgtype.UUID        `json:"snapshot_id"`
	Limit      int32              `json:"limit"`
}

type SearchFileSummariesByEmbeddingRow struct {
	ID         pgtype.UUID        `json:"id"`
	FileID     pgtype.UUID        `json:"file_id"`
	Summary    string             `json:"summary"`
	Embedding  pgvector_go.Vector `json:"embedding"`
	Metadata   []byte             `json:"metadata"`
	CreatedAt  pgtype.Timestamp   `json:"created_at"`
	UpdatedAt  pgtype.Timestamp   `json:"updated_at"`
	Path       string             `json:"path"`
	Language   pgtype.Text        `json:"language"`
	Similarity int32              `json:"similarity"`
}

func (q *Queries) SearchFileSummariesByEmbedding(ctx context.Context, arg SearchFileSummariesByEmbeddingParams) ([]SearchFileSummariesByEmbeddingRow, error) {
	rows, err := q.db.Query(ctx, searchFileSummariesByEmbedding, arg.Column1, arg.SnapshotID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchFileSummariesByEmbeddingRow{}
	for rows.Next() {
		var i SearchFileSummariesByEmbeddingRow
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.Summary,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Path,
			&i.Language,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertFileSummary = `-- name: UpsertFileSummary :one
INSERT INTO file_summaries (
    file_id,
    summary,
    embedding,
    metadata
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (file_id)
DO UPDATE SET
    summary = EXCLUDED.summary,
    embedding = EXCLUDED.embedding,
    metadata = EXCLUDED.metadata,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, file_id, summary, embedding, metadata, created_at, updated_at
`

type UpsertFileSummaryParams struct {
	FileID    pgtype.UUID        `json:"file_id"`
	Summary   string             `json:"summary"`
	Embedding pgvector_go.Vector `json:"embedding"`
	Metadata  []byte             `json:"metadata"`
}

func (q *Queries) UpsertFileSummary(ctx context.Context, arg UpsertFileSummaryParams) (FileSummary, error) {
	row := q.db.QueryRow(ctx, upsertFileSummary,
		arg.FileID,
		arg.Summary,
		arg.Embedding,
		arg.Metadata,
	)
	var i FileSummary
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.Summary,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
