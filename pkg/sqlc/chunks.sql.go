// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chunks.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createChunk = `-- name: CreateChunk :one
INSERT INTO chunks (file_id, ordinal, start_line, end_line, content, content_hash, token_count)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, file_id, ordinal, start_line, end_line, content, content_hash, token_count, created_at
`

type CreateChunkParams struct {
	FileID      pgtype.UUID `json:"file_id"`
	Ordinal     int32       `json:"ordinal"`
	StartLine   int32       `json:"start_line"`
	EndLine     int32       `json:"end_line"`
	Content     string      `json:"content"`
	ContentHash string      `json:"content_hash"`
	TokenCount  pgtype.Int4 `json:"token_count"`
}

func (q *Queries) CreateChunk(ctx context.Context, arg CreateChunkParams) (Chunk, error) {
	row := q.db.QueryRow(ctx, createChunk,
		arg.FileID,
		arg.Ordinal,
		arg.StartLine,
		arg.EndLine,
		arg.Content,
		arg.ContentHash,
		arg.TokenCount,
	)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.Ordinal,
		&i.StartLine,
		&i.EndLine,
		&i.Content,
		&i.ContentHash,
		&i.TokenCount,
		&i.CreatedAt,
	)
	return i, err
}

const deleteChunk = `-- name: DeleteChunk :exec
DELETE FROM chunks
WHERE id = $1
`

func (q *Queries) DeleteChunk(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChunk, id)
	return err
}

const deleteChunksByFile = `-- name: DeleteChunksByFile :exec
DELETE FROM chunks
WHERE file_id = $1
`

func (q *Queries) DeleteChunksByFile(ctx context.Context, fileID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChunksByFile, fileID)
	return err
}

const findChunksByContentHash = `-- name: FindChunksByContentHash :many
SELECT id, file_id, ordinal, start_line, end_line, content, content_hash, token_count, created_at FROM chunks
WHERE content_hash = $1
ORDER BY created_at DESC
`

func (q *Queries) FindChunksByContentHash(ctx context.Context, contentHash string) ([]Chunk, error) {
	rows, err := q.db.Query(ctx, findChunksByContentHash, contentHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chunk{}
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.Ordinal,
			&i.StartLine,
			&i.EndLine,
			&i.Content,
			&i.ContentHash,
			&i.TokenCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChunk = `-- name: GetChunk :one
SELECT id, file_id, ordinal, start_line, end_line, content, content_hash, token_count, created_at FROM chunks
WHERE id = $1
`

func (q *Queries) GetChunk(ctx context.Context, id pgtype.UUID) (Chunk, error) {
	row := q.db.QueryRow(ctx, getChunk, id)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.Ordinal,
		&i.StartLine,
		&i.EndLine,
		&i.Content,
		&i.ContentHash,
		&i.TokenCount,
		&i.CreatedAt,
	)
	return i, err
}

const listChunksByFile = `-- name: ListChunksByFile :many
SELECT id, file_id, ordinal, start_line, end_line, content, content_hash, token_count, created_at FROM chunks
WHERE file_id = $1
ORDER BY ordinal
`

func (q *Queries) ListChunksByFile(ctx context.Context, fileID pgtype.UUID) ([]Chunk, error) {
	rows, err := q.db.Query(ctx, listChunksByFile, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chunk{}
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.Ordinal,
			&i.StartLine,
			&i.EndLine,
			&i.Content,
			&i.ContentHash,
			&i.TokenCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChunksByOrdinalRange = `-- name: ListChunksByOrdinalRange :many
SELECT id, file_id, ordinal, start_line, end_line, content, content_hash, token_count, created_at FROM chunks
WHERE file_id = $1 AND ordinal BETWEEN $2 AND $3
ORDER BY ordinal
`

type ListChunksByOrdinalRangeParams struct {
	FileID    pgtype.UUID `json:"file_id"`
	Ordinal   int32       `json:"ordinal"`
	Ordinal_2 int32       `json:"ordinal_2"`
}

func (q *Queries) ListChunksByOrdinalRange(ctx context.Context, arg ListChunksByOrdinalRangeParams) ([]Chunk, error) {
	rows, err := q.db.Query(ctx, listChunksByOrdinalRange, arg.FileID, arg.Ordinal, arg.Ordinal_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chunk{}
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.Ordinal,
			&i.StartLine,
			&i.EndLine,
			&i.Content,
			&i.ContentHash,
			&i.TokenCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
