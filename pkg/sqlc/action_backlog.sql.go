// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: action_backlog.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActionsByPriority = `-- name: CountActionsByPriority :one
SELECT priority, COUNT(*) as count
FROM action_backlog
WHERE status = $1
GROUP BY priority
ORDER BY
    CASE priority
        WHEN 'P1' THEN 1
        WHEN 'P2' THEN 2
        WHEN 'P3' THEN 3
    END
`

type CountActionsByPriorityRow struct {
	Priority string `json:"priority"`
	Count    int64  `json:"count"`
}

func (q *Queries) CountActionsByPriority(ctx context.Context, status string) (CountActionsByPriorityRow, error) {
	row := q.db.QueryRow(ctx, countActionsByPriority, status)
	var i CountActionsByPriorityRow
	err := row.Scan(&i.Priority, &i.Count)
	return i, err
}

const countActionsByStatus = `-- name: CountActionsByStatus :one
SELECT status, COUNT(*) as count
FROM action_backlog
GROUP BY status
ORDER BY
    CASE status
        WHEN 'open' THEN 1
        WHEN 'noop' THEN 2
        WHEN 'completed' THEN 3
    END
`

type CountActionsByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountActionsByStatus(ctx context.Context) (CountActionsByStatusRow, error) {
	row := q.db.QueryRow(ctx, countActionsByStatus)
	var i CountActionsByStatusRow
	err := row.Scan(&i.Status, &i.Count)
	return i, err
}

const createAction = `-- name: CreateAction :one
INSERT INTO action_backlog (action_id, prompt_version, priority, action_type, title, description, linked_files, owner_hint, acceptance_criteria, status)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, action_id, prompt_version, priority, action_type, title, description, linked_files, owner_hint, acceptance_criteria, status, created_at, completed_at
`

type CreateActionParams struct {
	ActionID           string      `json:"action_id"`
	PromptVersion      string      `json:"prompt_version"`
	Priority           string      `json:"priority"`
	ActionType         string      `json:"action_type"`
	Title              string      `json:"title"`
	Description        string      `json:"description"`
	LinkedFiles        []byte      `json:"linked_files"`
	OwnerHint          pgtype.Text `json:"owner_hint"`
	AcceptanceCriteria string      `json:"acceptance_criteria"`
	Status             string      `json:"status"`
}

func (q *Queries) CreateAction(ctx context.Context, arg CreateActionParams) (ActionBacklog, error) {
	row := q.db.QueryRow(ctx, createAction,
		arg.ActionID,
		arg.PromptVersion,
		arg.Priority,
		arg.ActionType,
		arg.Title,
		arg.Description,
		arg.LinkedFiles,
		arg.OwnerHint,
		arg.AcceptanceCriteria,
		arg.Status,
	)
	var i ActionBacklog
	err := row.Scan(
		&i.ID,
		&i.ActionID,
		&i.PromptVersion,
		&i.Priority,
		&i.ActionType,
		&i.Title,
		&i.Description,
		&i.LinkedFiles,
		&i.OwnerHint,
		&i.AcceptanceCriteria,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const deleteAction = `-- name: DeleteAction :exec
DELETE FROM action_backlog
WHERE id = $1
`

func (q *Queries) DeleteAction(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAction, id)
	return err
}

const getAction = `-- name: GetAction :one
SELECT id, action_id, prompt_version, priority, action_type, title, description, linked_files, owner_hint, acceptance_criteria, status, created_at, completed_at FROM action_backlog
WHERE id = $1
`

func (q *Queries) GetAction(ctx context.Context, id pgtype.UUID) (ActionBacklog, error) {
	row := q.db.QueryRow(ctx, getAction, id)
	var i ActionBacklog
	err := row.Scan(
		&i.ID,
		&i.ActionID,
		&i.PromptVersion,
		&i.Priority,
		&i.ActionType,
		&i.Title,
		&i.Description,
		&i.LinkedFiles,
		&i.OwnerHint,
		&i.AcceptanceCriteria,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getActionByActionID = `-- name: GetActionByActionID :one
SELECT id, action_id, prompt_version, priority, action_type, title, description, linked_files, owner_hint, acceptance_criteria, status, created_at, completed_at FROM action_backlog
WHERE action_id = $1
`

func (q *Queries) GetActionByActionID(ctx context.Context, actionID string) (ActionBacklog, error) {
	row := q.db.QueryRow(ctx, getActionByActionID, actionID)
	var i ActionBacklog
	err := row.Scan(
		&i.ID,
		&i.ActionID,
		&i.PromptVersion,
		&i.Priority,
		&i.ActionType,
		&i.Title,
		&i.Description,
		&i.LinkedFiles,
		&i.OwnerHint,
		&i.AcceptanceCriteria,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listActions = `-- name: ListActions :many
SELECT id, action_id, prompt_version, priority, action_type, title, description, linked_files, owner_hint, acceptance_criteria, status, created_at, completed_at FROM action_backlog
WHERE
    ($1::text IS NULL OR priority = $1) AND
    ($2::text IS NULL OR action_type = $2) AND
    ($3::text IS NULL OR status = $3)
ORDER BY
    CASE priority
        WHEN 'P1' THEN 1
        WHEN 'P2' THEN 2
        WHEN 'P3' THEN 3
    END,
    created_at DESC
LIMIT COALESCE($4, 100)
`

type ListActionsParams struct {
	Priority   string      `json:"priority"`
	ActionType string      `json:"action_type"`
	Status     string      `json:"status"`
	LimitCount interface{} `json:"limit_count"`
}

func (q *Queries) ListActions(ctx context.Context, arg ListActionsParams) ([]ActionBacklog, error) {
	rows, err := q.db.Query(ctx, listActions,
		arg.Priority,
		arg.ActionType,
		arg.Status,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActionBacklog{}
	for rows.Next() {
		var i ActionBacklog
		if err := rows.Scan(
			&i.ID,
			&i.ActionID,
			&i.PromptVersion,
			&i.Priority,
			&i.ActionType,
			&i.Title,
			&i.Description,
			&i.LinkedFiles,
			&i.OwnerHint,
			&i.AcceptanceCriteria,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsByPriority = `-- name: ListActionsByPriority :many
SELECT id, action_id, prompt_version, priority, action_type, title, description, linked_files, owner_hint, acceptance_criteria, status, created_at, completed_at FROM action_backlog
WHERE priority = $1
ORDER BY created_at DESC
`

func (q *Queries) ListActionsByPriority(ctx context.Context, priority string) ([]ActionBacklog, error) {
	rows, err := q.db.Query(ctx, listActionsByPriority, priority)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActionBacklog{}
	for rows.Next() {
		var i ActionBacklog
		if err := rows.Scan(
			&i.ID,
			&i.ActionID,
			&i.PromptVersion,
			&i.Priority,
			&i.ActionType,
			&i.Title,
			&i.Description,
			&i.LinkedFiles,
			&i.OwnerHint,
			&i.AcceptanceCriteria,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsByStatus = `-- name: ListActionsByStatus :many
SELECT id, action_id, prompt_version, priority, action_type, title, description, linked_files, owner_hint, acceptance_criteria, status, created_at, completed_at FROM action_backlog
WHERE status = $1
ORDER BY
    CASE priority
        WHEN 'P1' THEN 1
        WHEN 'P2' THEN 2
        WHEN 'P3' THEN 3
    END,
    created_at DESC
`

func (q *Queries) ListActionsByStatus(ctx context.Context, status string) ([]ActionBacklog, error) {
	rows, err := q.db.Query(ctx, listActionsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActionBacklog{}
	for rows.Next() {
		var i ActionBacklog
		if err := rows.Scan(
			&i.ID,
			&i.ActionID,
			&i.PromptVersion,
			&i.Priority,
			&i.ActionType,
			&i.Title,
			&i.Description,
			&i.LinkedFiles,
			&i.OwnerHint,
			&i.AcceptanceCriteria,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsByType = `-- name: ListActionsByType :many
SELECT id, action_id, prompt_version, priority, action_type, title, description, linked_files, owner_hint, acceptance_criteria, status, created_at, completed_at FROM action_backlog
WHERE action_type = $1
ORDER BY created_at DESC
`

func (q *Queries) ListActionsByType(ctx context.Context, actionType string) ([]ActionBacklog, error) {
	rows, err := q.db.Query(ctx, listActionsByType, actionType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActionBacklog{}
	for rows.Next() {
		var i ActionBacklog
		if err := rows.Scan(
			&i.ID,
			&i.ActionID,
			&i.PromptVersion,
			&i.Priority,
			&i.ActionType,
			&i.Title,
			&i.Description,
			&i.LinkedFiles,
			&i.OwnerHint,
			&i.AcceptanceCriteria,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingActions = `-- name: ListPendingActions :many
SELECT id, action_id, prompt_version, priority, action_type, title, description, linked_files, owner_hint, acceptance_criteria, status, created_at, completed_at FROM action_backlog
WHERE status = 'open' AND completed_at IS NULL
ORDER BY
    CASE priority
        WHEN 'P1' THEN 1
        WHEN 'P2' THEN 2
        WHEN 'P3' THEN 3
    END,
    created_at DESC
`

func (q *Queries) ListPendingActions(ctx context.Context) ([]ActionBacklog, error) {
	rows, err := q.db.Query(ctx, listPendingActions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActionBacklog{}
	for rows.Next() {
		var i ActionBacklog
		if err := rows.Scan(
			&i.ID,
			&i.ActionID,
			&i.PromptVersion,
			&i.Priority,
			&i.ActionType,
			&i.Title,
			&i.Description,
			&i.LinkedFiles,
			&i.OwnerHint,
			&i.AcceptanceCriteria,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateActionStatus = `-- name: UpdateActionStatus :one
UPDATE action_backlog
SET status = $2, completed_at = $3
WHERE id = $1
RETURNING id, action_id, prompt_version, priority, action_type, title, description, linked_files, owner_hint, acceptance_criteria, status, created_at, completed_at
`

type UpdateActionStatusParams struct {
	ID          pgtype.UUID      `json:"id"`
	Status      string           `json:"status"`
	CompletedAt pgtype.Timestamp `json:"completed_at"`
}

func (q *Queries) UpdateActionStatus(ctx context.Context, arg UpdateActionStatusParams) (ActionBacklog, error) {
	row := q.db.QueryRow(ctx, updateActionStatus, arg.ID, arg.Status, arg.CompletedAt)
	var i ActionBacklog
	err := row.Scan(
		&i.ID,
		&i.ActionID,
		&i.PromptVersion,
		&i.Priority,
		&i.ActionType,
		&i.Title,
		&i.Description,
		&i.LinkedFiles,
		&i.OwnerHint,
		&i.AcceptanceCriteria,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}
