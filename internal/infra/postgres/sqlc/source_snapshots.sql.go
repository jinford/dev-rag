// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: source_snapshots.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSourceSnapshot = `-- name: CreateSourceSnapshot :one
INSERT INTO source_snapshots (source_id, version_identifier)
VALUES ($1, $2)
RETURNING id, source_id, version_identifier, indexed, indexed_at, created_at
`

type CreateSourceSnapshotParams struct {
	SourceID          pgtype.UUID `json:"source_id"`
	VersionIdentifier string      `json:"version_identifier"`
}

func (q *Queries) CreateSourceSnapshot(ctx context.Context, arg CreateSourceSnapshotParams) (SourceSnapshot, error) {
	row := q.db.QueryRow(ctx, createSourceSnapshot, arg.SourceID, arg.VersionIdentifier)
	var i SourceSnapshot
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.VersionIdentifier,
		&i.Indexed,
		&i.IndexedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSourceSnapshot = `-- name: DeleteSourceSnapshot :exec
DELETE FROM source_snapshots
WHERE id = $1
`

func (q *Queries) DeleteSourceSnapshot(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSourceSnapshot, id)
	return err
}

const getLatestIndexedSnapshot = `-- name: GetLatestIndexedSnapshot :one
SELECT id, source_id, version_identifier, indexed, indexed_at, created_at FROM source_snapshots
WHERE source_id = $1 AND indexed = TRUE
ORDER BY indexed_at DESC NULLS LAST, created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestIndexedSnapshot(ctx context.Context, sourceID pgtype.UUID) (SourceSnapshot, error) {
	row := q.db.QueryRow(ctx, getLatestIndexedSnapshot, sourceID)
	var i SourceSnapshot
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.VersionIdentifier,
		&i.Indexed,
		&i.IndexedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSourceSnapshot = `-- name: GetSourceSnapshot :one
SELECT id, source_id, version_identifier, indexed, indexed_at, created_at FROM source_snapshots
WHERE id = $1
`

func (q *Queries) GetSourceSnapshot(ctx context.Context, id pgtype.UUID) (SourceSnapshot, error) {
	row := q.db.QueryRow(ctx, getSourceSnapshot, id)
	var i SourceSnapshot
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.VersionIdentifier,
		&i.Indexed,
		&i.IndexedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSourceSnapshotByVersion = `-- name: GetSourceSnapshotByVersion :one
SELECT id, source_id, version_identifier, indexed, indexed_at, created_at FROM source_snapshots
WHERE source_id = $1 AND version_identifier = $2
`

type GetSourceSnapshotByVersionParams struct {
	SourceID          pgtype.UUID `json:"source_id"`
	VersionIdentifier string      `json:"version_identifier"`
}

func (q *Queries) GetSourceSnapshotByVersion(ctx context.Context, arg GetSourceSnapshotByVersionParams) (SourceSnapshot, error) {
	row := q.db.QueryRow(ctx, getSourceSnapshotByVersion, arg.SourceID, arg.VersionIdentifier)
	var i SourceSnapshot
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.VersionIdentifier,
		&i.Indexed,
		&i.IndexedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listIndexedSnapshots = `-- name: ListIndexedSnapshots :many
SELECT id, source_id, version_identifier, indexed, indexed_at, created_at FROM source_snapshots
WHERE indexed = TRUE
ORDER BY indexed_at DESC
`

func (q *Queries) ListIndexedSnapshots(ctx context.Context) ([]SourceSnapshot, error) {
	rows, err := q.db.Query(ctx, listIndexedSnapshots)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SourceSnapshot{}
	for rows.Next() {
		var i SourceSnapshot
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.VersionIdentifier,
			&i.Indexed,
			&i.IndexedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSourceSnapshotsBySource = `-- name: ListSourceSnapshotsBySource :many
SELECT id, source_id, version_identifier, indexed, indexed_at, created_at FROM source_snapshots
WHERE source_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListSourceSnapshotsBySource(ctx context.Context, sourceID pgtype.UUID) ([]SourceSnapshot, error) {
	rows, err := q.db.Query(ctx, listSourceSnapshotsBySource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SourceSnapshot{}
	for rows.Next() {
		var i SourceSnapshot
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.VersionIdentifier,
			&i.Indexed,
			&i.IndexedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSnapshotIndexed = `-- name: MarkSnapshotIndexed :one
UPDATE source_snapshots
SET indexed = TRUE, indexed_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, source_id, version_identifier, indexed, indexed_at, created_at
`

func (q *Queries) MarkSnapshotIndexed(ctx context.Context, id pgtype.UUID) (SourceSnapshot, error) {
	row := q.db.QueryRow(ctx, markSnapshotIndexed, id)
	var i SourceSnapshot
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.VersionIdentifier,
		&i.Indexed,
		&i.IndexedAt,
		&i.CreatedAt,
	)
	return i, err
}
