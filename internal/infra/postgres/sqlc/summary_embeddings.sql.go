// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: summary_embeddings.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const countSummaryEmbeddingsBySnapshot = `-- name: CountSummaryEmbeddingsBySnapshot :one
SELECT COUNT(*) FROM summary_embeddings se
JOIN summaries s ON se.summary_id = s.id
WHERE s.snapshot_id = $1
`

func (q *Queries) CountSummaryEmbeddingsBySnapshot(ctx context.Context, snapshotID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSummaryEmbeddingsBySnapshot, snapshotID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSummaryEmbedding = `-- name: CreateSummaryEmbedding :one
INSERT INTO summary_embeddings (summary_id, vector, model)
VALUES ($1, $2, $3)
RETURNING summary_id, vector, model, created_at
`

type CreateSummaryEmbeddingParams struct {
	SummaryID pgtype.UUID        `json:"summary_id"`
	Vector    pgvector_go.Vector `json:"vector"`
	Model     string             `json:"model"`
}

func (q *Queries) CreateSummaryEmbedding(ctx context.Context, arg CreateSummaryEmbeddingParams) (SummaryEmbedding, error) {
	row := q.db.QueryRow(ctx, createSummaryEmbedding, arg.SummaryID, arg.Vector, arg.Model)
	var i SummaryEmbedding
	err := row.Scan(
		&i.SummaryID,
		&i.Vector,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSummaryEmbedding = `-- name: DeleteSummaryEmbedding :exec
DELETE FROM summary_embeddings WHERE summary_id = $1
`

func (q *Queries) DeleteSummaryEmbedding(ctx context.Context, summaryID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSummaryEmbedding, summaryID)
	return err
}

const deleteSummaryEmbeddingsBySnapshot = `-- name: DeleteSummaryEmbeddingsBySnapshot :exec
DELETE FROM summary_embeddings
WHERE summary_id IN (
    SELECT id FROM summaries WHERE snapshot_id = $1
)
`

func (q *Queries) DeleteSummaryEmbeddingsBySnapshot(ctx context.Context, snapshotID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSummaryEmbeddingsBySnapshot, snapshotID)
	return err
}

const getSummaryEmbedding = `-- name: GetSummaryEmbedding :one
SELECT summary_id, vector, model, created_at FROM summary_embeddings WHERE summary_id = $1
`

func (q *Queries) GetSummaryEmbedding(ctx context.Context, summaryID pgtype.UUID) (SummaryEmbedding, error) {
	row := q.db.QueryRow(ctx, getSummaryEmbedding, summaryID)
	var i SummaryEmbedding
	err := row.Scan(
		&i.SummaryID,
		&i.Vector,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const searchArchitectureSummaryEmbeddings = `-- name: SearchArchitectureSummaryEmbeddings :many
SELECT s.id, s.snapshot_id, s.summary_type, s.target_path, s.depth, s.parent_path, s.arch_type, s.content, s.content_hash, s.source_hash, s.metadata, s.created_at, s.updated_at, se.vector, (1 - (se.vector <=> $1::vector))::float8 AS score
FROM summaries s
JOIN summary_embeddings se ON s.id = se.summary_id
WHERE s.snapshot_id = $2 AND s.summary_type = 'architecture'
ORDER BY se.vector <=> $1::vector
LIMIT $3
`

type SearchArchitectureSummaryEmbeddingsParams struct {
	Column1    pgvector_go.Vector `json:"column_1"`
	SnapshotID pgtype.UUID        `json:"snapshot_id"`
	Limit      int32              `json:"limit"`
}

type SearchArchitectureSummaryEmbeddingsRow struct {
	ID          pgtype.UUID        `json:"id"`
	SnapshotID  pgtype.UUID        `json:"snapshot_id"`
	SummaryType string             `json:"summary_type"`
	TargetPath  string             `json:"target_path"`
	Depth       pgtype.Int4        `json:"depth"`
	ParentPath  pgtype.Text        `json:"parent_path"`
	ArchType    pgtype.Text        `json:"arch_type"`
	Content     string             `json:"content"`
	ContentHash string             `json:"content_hash"`
	SourceHash  string             `json:"source_hash"`
	Metadata    []byte             `json:"metadata"`
	CreatedAt   pgtype.Timestamp   `json:"created_at"`
	UpdatedAt   pgtype.Timestamp   `json:"updated_at"`
	Vector      pgvector_go.Vector `json:"vector"`
	Score       float64            `json:"score"`
}

func (q *Queries) SearchArchitectureSummaryEmbeddings(ctx context.Context, arg SearchArchitectureSummaryEmbeddingsParams) ([]SearchArchitectureSummaryEmbeddingsRow, error) {
	rows, err := q.db.Query(ctx, searchArchitectureSummaryEmbeddings, arg.Column1, arg.SnapshotID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchArchitectureSummaryEmbeddingsRow{}
	for rows.Next() {
		var i SearchArchitectureSummaryEmbeddingsRow
		if err := rows.Scan(
			&i.ID,
			&i.SnapshotID,
			&i.SummaryType,
			&i.TargetPath,
			&i.Depth,
			&i.ParentPath,
			&i.ArchType,
			&i.Content,
			&i.ContentHash,
			&i.SourceHash,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Vector,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDirectorySummaryEmbeddings = `-- name: SearchDirectorySummaryEmbeddings :many
SELECT s.id, s.snapshot_id, s.summary_type, s.target_path, s.depth, s.parent_path, s.arch_type, s.content, s.content_hash, s.source_hash, s.metadata, s.created_at, s.updated_at, se.vector, (1 - (se.vector <=> $1::vector))::float8 AS score
FROM summaries s
JOIN summary_embeddings se ON s.id = se.summary_id
WHERE s.snapshot_id = $2 AND s.summary_type = 'directory'
ORDER BY se.vector <=> $1::vector
LIMIT $3
`

type SearchDirectorySummaryEmbeddingsParams struct {
	Column1    pgvector_go.Vector `json:"column_1"`
	SnapshotID pgtype.UUID        `json:"snapshot_id"`
	Limit      int32              `json:"limit"`
}

type SearchDirectorySummaryEmbeddingsRow struct {
	ID          pgtype.UUID        `json:"id"`
	SnapshotID  pgtype.UUID        `json:"snapshot_id"`
	SummaryType string             `json:"summary_type"`
	TargetPath  string             `json:"target_path"`
	Depth       pgtype.Int4        `json:"depth"`
	ParentPath  pgtype.Text        `json:"parent_path"`
	ArchType    pgtype.Text        `json:"arch_type"`
	Content     string             `json:"content"`
	ContentHash string             `json:"content_hash"`
	SourceHash  string             `json:"source_hash"`
	Metadata    []byte             `json:"metadata"`
	CreatedAt   pgtype.Timestamp   `json:"created_at"`
	UpdatedAt   pgtype.Timestamp   `json:"updated_at"`
	Vector      pgvector_go.Vector `json:"vector"`
	Score       float64            `json:"score"`
}

func (q *Queries) SearchDirectorySummaryEmbeddings(ctx context.Context, arg SearchDirectorySummaryEmbeddingsParams) ([]SearchDirectorySummaryEmbeddingsRow, error) {
	rows, err := q.db.Query(ctx, searchDirectorySummaryEmbeddings, arg.Column1, arg.SnapshotID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchDirectorySummaryEmbeddingsRow{}
	for rows.Next() {
		var i SearchDirectorySummaryEmbeddingsRow
		if err := rows.Scan(
			&i.ID,
			&i.SnapshotID,
			&i.SummaryType,
			&i.TargetPath,
			&i.Depth,
			&i.ParentPath,
			&i.ArchType,
			&i.Content,
			&i.ContentHash,
			&i.SourceHash,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Vector,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFileSummaryEmbeddings = `-- name: SearchFileSummaryEmbeddings :many
SELECT s.id, s.snapshot_id, s.summary_type, s.target_path, s.depth, s.parent_path, s.arch_type, s.content, s.content_hash, s.source_hash, s.metadata, s.created_at, s.updated_at, se.vector, (1 - (se.vector <=> $1::vector))::float8 AS score
FROM summaries s
JOIN summary_embeddings se ON s.id = se.summary_id
WHERE s.snapshot_id = $2 AND s.summary_type = 'file'
ORDER BY se.vector <=> $1::vector
LIMIT $3
`

type SearchFileSummaryEmbeddingsParams struct {
	Column1    pgvector_go.Vector `json:"column_1"`
	SnapshotID pgtype.UUID        `json:"snapshot_id"`
	Limit      int32              `json:"limit"`
}

type SearchFileSummaryEmbeddingsRow struct {
	ID          pgtype.UUID        `json:"id"`
	SnapshotID  pgtype.UUID        `json:"snapshot_id"`
	SummaryType string             `json:"summary_type"`
	TargetPath  string             `json:"target_path"`
	Depth       pgtype.Int4        `json:"depth"`
	ParentPath  pgtype.Text        `json:"parent_path"`
	ArchType    pgtype.Text        `json:"arch_type"`
	Content     string             `json:"content"`
	ContentHash string             `json:"content_hash"`
	SourceHash  string             `json:"source_hash"`
	Metadata    []byte             `json:"metadata"`
	CreatedAt   pgtype.Timestamp   `json:"created_at"`
	UpdatedAt   pgtype.Timestamp   `json:"updated_at"`
	Vector      pgvector_go.Vector `json:"vector"`
	Score       float64            `json:"score"`
}

func (q *Queries) SearchFileSummaryEmbeddings(ctx context.Context, arg SearchFileSummaryEmbeddingsParams) ([]SearchFileSummaryEmbeddingsRow, error) {
	rows, err := q.db.Query(ctx, searchFileSummaryEmbeddings, arg.Column1, arg.SnapshotID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchFileSummaryEmbeddingsRow{}
	for rows.Next() {
		var i SearchFileSummaryEmbeddingsRow
		if err := rows.Scan(
			&i.ID,
			&i.SnapshotID,
			&i.SummaryType,
			&i.TargetPath,
			&i.Depth,
			&i.ParentPath,
			&i.ArchType,
			&i.Content,
			&i.ContentHash,
			&i.SourceHash,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Vector,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSummariesByProduct = `-- name: SearchSummariesByProduct :many
WITH latest_snapshots AS (
    SELECT DISTINCT ON (source_id) id, source_id
    FROM source_snapshots
    WHERE indexed = TRUE
    ORDER BY source_id, indexed_at DESC NULLS LAST, created_at DESC
)
SELECT
    s.id,
    s.snapshot_id,
    s.summary_type,
    s.target_path,
    s.arch_type,
    s.content,
    (1 - (se.vector <=> $1::vector))::float8 as score
FROM summaries s
JOIN summary_embeddings se ON s.id = se.summary_id
JOIN latest_snapshots ls ON s.snapshot_id = ls.id
JOIN sources src ON ls.source_id = src.id
WHERE src.product_id = $2
  AND (cardinality($3::text[]) = 0 OR s.summary_type = ANY($3::text[]))
  AND ($4::text IS NULL OR s.target_path LIKE $4::text || '%')
ORDER BY se.vector <=> $1::vector
LIMIT $5
`

type SearchSummariesByProductParams struct {
	QueryVector  pgvector_go.Vector `json:"query_vector"`
	ProductID    pgtype.UUID        `json:"product_id"`
	SummaryTypes []string           `json:"summary_types"`
	PathPrefix   pgtype.Text        `json:"path_prefix"`
	LimitVal     int32              `json:"limit_val"`
}

type SearchSummariesByProductRow struct {
	ID          pgtype.UUID `json:"id"`
	SnapshotID  pgtype.UUID `json:"snapshot_id"`
	SummaryType string      `json:"summary_type"`
	TargetPath  string      `json:"target_path"`
	ArchType    pgtype.Text `json:"arch_type"`
	Content     string      `json:"content"`
	Score       float64     `json:"score"`
}

func (q *Queries) SearchSummariesByProduct(ctx context.Context, arg SearchSummariesByProductParams) ([]SearchSummariesByProductRow, error) {
	rows, err := q.db.Query(ctx, searchSummariesByProduct,
		arg.QueryVector,
		arg.ProductID,
		arg.SummaryTypes,
		arg.PathPrefix,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSummariesByProductRow{}
	for rows.Next() {
		var i SearchSummariesByProductRow
		if err := rows.Scan(
			&i.ID,
			&i.SnapshotID,
			&i.SummaryType,
			&i.TargetPath,
			&i.ArchType,
			&i.Content,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSummariesBySnapshot = `-- name: SearchSummariesBySnapshot :many
SELECT
    s.id,
    s.summary_type,
    s.target_path,
    s.arch_type,
    s.content,
    (1 - (se.vector <=> $1::vector))::float8 as score
FROM summaries s
JOIN summary_embeddings se ON s.id = se.summary_id
WHERE s.snapshot_id = $2
  AND (cardinality($3::text[]) = 0 OR s.summary_type = ANY($3::text[]))
  AND ($4::text IS NULL OR s.target_path LIKE $4::text || '%')
ORDER BY se.vector <=> $1::vector
LIMIT $5
`

type SearchSummariesBySnapshotParams struct {
	QueryVector  pgvector_go.Vector `json:"query_vector"`
	SnapshotID   pgtype.UUID        `json:"snapshot_id"`
	SummaryTypes []string           `json:"summary_types"`
	PathPrefix   string             `json:"path_prefix"`
	LimitVal     int32              `json:"limit_val"`
}

type SearchSummariesBySnapshotRow struct {
	ID          pgtype.UUID `json:"id"`
	SummaryType string      `json:"summary_type"`
	TargetPath  string      `json:"target_path"`
	ArchType    pgtype.Text `json:"arch_type"`
	Content     string      `json:"content"`
	Score       float64     `json:"score"`
}

func (q *Queries) SearchSummariesBySnapshot(ctx context.Context, arg SearchSummariesBySnapshotParams) ([]SearchSummariesBySnapshotRow, error) {
	rows, err := q.db.Query(ctx, searchSummariesBySnapshot,
		arg.QueryVector,
		arg.SnapshotID,
		arg.SummaryTypes,
		arg.PathPrefix,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSummariesBySnapshotRow{}
	for rows.Next() {
		var i SearchSummariesBySnapshotRow
		if err := rows.Scan(
			&i.ID,
			&i.SummaryType,
			&i.TargetPath,
			&i.ArchType,
			&i.Content,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSummaryEmbeddings = `-- name: SearchSummaryEmbeddings :many
SELECT s.id, s.snapshot_id, s.summary_type, s.target_path, s.depth, s.parent_path, s.arch_type, s.content, s.content_hash, s.source_hash, s.metadata, s.created_at, s.updated_at, se.vector, (1 - (se.vector <=> $1::vector))::float8 AS score
FROM summaries s
JOIN summary_embeddings se ON s.id = se.summary_id
WHERE s.snapshot_id = $2
ORDER BY se.vector <=> $1::vector
LIMIT $3
`

type SearchSummaryEmbeddingsParams struct {
	Column1    pgvector_go.Vector `json:"column_1"`
	SnapshotID pgtype.UUID        `json:"snapshot_id"`
	Limit      int32              `json:"limit"`
}

type SearchSummaryEmbeddingsRow struct {
	ID          pgtype.UUID        `json:"id"`
	SnapshotID  pgtype.UUID        `json:"snapshot_id"`
	SummaryType string             `json:"summary_type"`
	TargetPath  string             `json:"target_path"`
	Depth       pgtype.Int4        `json:"depth"`
	ParentPath  pgtype.Text        `json:"parent_path"`
	ArchType    pgtype.Text        `json:"arch_type"`
	Content     string             `json:"content"`
	ContentHash string             `json:"content_hash"`
	SourceHash  string             `json:"source_hash"`
	Metadata    []byte             `json:"metadata"`
	CreatedAt   pgtype.Timestamp   `json:"created_at"`
	UpdatedAt   pgtype.Timestamp   `json:"updated_at"`
	Vector      pgvector_go.Vector `json:"vector"`
	Score       float64            `json:"score"`
}

func (q *Queries) SearchSummaryEmbeddings(ctx context.Context, arg SearchSummaryEmbeddingsParams) ([]SearchSummaryEmbeddingsRow, error) {
	rows, err := q.db.Query(ctx, searchSummaryEmbeddings, arg.Column1, arg.SnapshotID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSummaryEmbeddingsRow{}
	for rows.Next() {
		var i SearchSummaryEmbeddingsRow
		if err := rows.Scan(
			&i.ID,
			&i.SnapshotID,
			&i.SummaryType,
			&i.TargetPath,
			&i.Depth,
			&i.ParentPath,
			&i.ArchType,
			&i.Content,
			&i.ContentHash,
			&i.SourceHash,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Vector,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSummaryEmbedding = `-- name: UpsertSummaryEmbedding :one
INSERT INTO summary_embeddings (summary_id, vector, model)
VALUES ($1, $2, $3)
ON CONFLICT (summary_id)
DO UPDATE SET vector = EXCLUDED.vector, model = EXCLUDED.model, created_at = CURRENT_TIMESTAMP
RETURNING summary_id, vector, model, created_at
`

type UpsertSummaryEmbeddingParams struct {
	SummaryID pgtype.UUID        `json:"summary_id"`
	Vector    pgvector_go.Vector `json:"vector"`
	Model     string             `json:"model"`
}

func (q *Queries) UpsertSummaryEmbedding(ctx context.Context, arg UpsertSummaryEmbeddingParams) (SummaryEmbedding, error) {
	row := q.db.QueryRow(ctx, upsertSummaryEmbedding, arg.SummaryID, arg.Vector, arg.Model)
	var i SummaryEmbedding
	err := row.Scan(
		&i.SummaryID,
		&i.Vector,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}
