// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: architecture_summaries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const countArchitectureSummaries = `-- name: CountArchitectureSummaries :one
SELECT COUNT(*) FROM architecture_summaries
WHERE snapshot_id = $1
`

func (q *Queries) CountArchitectureSummaries(ctx context.Context, snapshotID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countArchitectureSummaries, snapshotID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createArchitectureSummary = `-- name: CreateArchitectureSummary :one
INSERT INTO architecture_summaries (
    snapshot_id,
    summary_type,
    summary,
    embedding,
    metadata
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, snapshot_id, summary_type, summary, embedding, metadata, created_at, updated_at
`

type CreateArchitectureSummaryParams struct {
	SnapshotID  pgtype.UUID        `json:"snapshot_id"`
	SummaryType string             `json:"summary_type"`
	Summary     string             `json:"summary"`
	Embedding   pgvector_go.Vector `json:"embedding"`
	Metadata    []byte             `json:"metadata"`
}

func (q *Queries) CreateArchitectureSummary(ctx context.Context, arg CreateArchitectureSummaryParams) (ArchitectureSummary, error) {
	row := q.db.QueryRow(ctx, createArchitectureSummary,
		arg.SnapshotID,
		arg.SummaryType,
		arg.Summary,
		arg.Embedding,
		arg.Metadata,
	)
	var i ArchitectureSummary
	err := row.Scan(
		&i.ID,
		&i.SnapshotID,
		&i.SummaryType,
		&i.Summary,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteArchitectureSummariesBySnapshot = `-- name: DeleteArchitectureSummariesBySnapshot :exec
DELETE FROM architecture_summaries
WHERE snapshot_id = $1
`

func (q *Queries) DeleteArchitectureSummariesBySnapshot(ctx context.Context, snapshotID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteArchitectureSummariesBySnapshot, snapshotID)
	return err
}

const deleteArchitectureSummaryByType = `-- name: DeleteArchitectureSummaryByType :exec
DELETE FROM architecture_summaries
WHERE snapshot_id = $1 AND summary_type = $2
`

type DeleteArchitectureSummaryByTypeParams struct {
	SnapshotID  pgtype.UUID `json:"snapshot_id"`
	SummaryType string      `json:"summary_type"`
}

func (q *Queries) DeleteArchitectureSummaryByType(ctx context.Context, arg DeleteArchitectureSummaryByTypeParams) error {
	_, err := q.db.Exec(ctx, deleteArchitectureSummaryByType, arg.SnapshotID, arg.SummaryType)
	return err
}

const getAllArchitectureSummaryTypes = `-- name: GetAllArchitectureSummaryTypes :many
SELECT DISTINCT summary_type
FROM architecture_summaries
ORDER BY summary_type
`

func (q *Queries) GetAllArchitectureSummaryTypes(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllArchitectureSummaryTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var summary_type string
		if err := rows.Scan(&summary_type); err != nil {
			return nil, err
		}
		items = append(items, summary_type)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArchitectureSummary = `-- name: GetArchitectureSummary :one
SELECT summary FROM architecture_summaries
WHERE snapshot_id = $1 AND summary_type = $2
`

type GetArchitectureSummaryParams struct {
	SnapshotID  pgtype.UUID `json:"snapshot_id"`
	SummaryType string      `json:"summary_type"`
}

func (q *Queries) GetArchitectureSummary(ctx context.Context, arg GetArchitectureSummaryParams) (string, error) {
	row := q.db.QueryRow(ctx, getArchitectureSummary, arg.SnapshotID, arg.SummaryType)
	var summary string
	err := row.Scan(&summary)
	return summary, err
}

const getArchitectureSummaryByID = `-- name: GetArchitectureSummaryByID :one
SELECT id, snapshot_id, summary_type, summary, embedding, metadata, created_at, updated_at FROM architecture_summaries
WHERE id = $1
`

func (q *Queries) GetArchitectureSummaryByID(ctx context.Context, id pgtype.UUID) (ArchitectureSummary, error) {
	row := q.db.QueryRow(ctx, getArchitectureSummaryByID, id)
	var i ArchitectureSummary
	err := row.Scan(
		&i.ID,
		&i.SnapshotID,
		&i.SummaryType,
		&i.Summary,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const hasAllRequiredArchitectureSummaries = `-- name: HasAllRequiredArchitectureSummaries :one
SELECT
    COUNT(DISTINCT summary_type) = 4 AS has_all
FROM architecture_summaries
WHERE snapshot_id = $1
AND summary_type IN ('overview', 'tech_stack', 'data_flow', 'components')
`

func (q *Queries) HasAllRequiredArchitectureSummaries(ctx context.Context, snapshotID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, hasAllRequiredArchitectureSummaries, snapshotID)
	var has_all bool
	err := row.Scan(&has_all)
	return has_all, err
}

const listArchitectureSummariesBySnapshot = `-- name: ListArchitectureSummariesBySnapshot :many
SELECT id, snapshot_id, summary_type, summary, embedding, metadata, created_at, updated_at FROM architecture_summaries
WHERE snapshot_id = $1
ORDER BY summary_type ASC
`

func (q *Queries) ListArchitectureSummariesBySnapshot(ctx context.Context, snapshotID pgtype.UUID) ([]ArchitectureSummary, error) {
	rows, err := q.db.Query(ctx, listArchitectureSummariesBySnapshot, snapshotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ArchitectureSummary{}
	for rows.Next() {
		var i ArchitectureSummary
		if err := rows.Scan(
			&i.ID,
			&i.SnapshotID,
			&i.SummaryType,
			&i.Summary,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArchitectureSummariesByType = `-- name: ListArchitectureSummariesByType :many
SELECT id, snapshot_id, summary_type, summary, embedding, metadata, created_at, updated_at FROM architecture_summaries
WHERE summary_type = $1
ORDER BY created_at DESC
`

func (q *Queries) ListArchitectureSummariesByType(ctx context.Context, summaryType string) ([]ArchitectureSummary, error) {
	rows, err := q.db.Query(ctx, listArchitectureSummariesByType, summaryType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ArchitectureSummary{}
	for rows.Next() {
		var i ArchitectureSummary
		if err := rows.Scan(
			&i.ID,
			&i.SnapshotID,
			&i.SummaryType,
			&i.Summary,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchArchitectureSummariesByEmbedding = `-- name: SearchArchitectureSummariesByEmbedding :many
SELECT
    id, snapshot_id, summary_type, summary, embedding, metadata, created_at, updated_at,
    1 - (embedding <=> $1::vector) AS similarity
FROM architecture_summaries
WHERE snapshot_id = $2
ORDER BY embedding <=> $1::vector
LIMIT $3
`

type SearchArchitectureSummariesByEmbeddingParams struct {
	Column1    pgvector_go.Vector `json:"column_1"`
	SnapshotID pgtype.UUID        `json:"snapshot_id"`
	Limit      int32              `json:"limit"`
}

type SearchArchitectureSummariesByEmbeddingRow struct {
	ID          pgtype.UUID        `json:"id"`
	SnapshotID  pgtype.UUID        `json:"snapshot_id"`
	SummaryType string             `json:"summary_type"`
	Summary     string             `json:"summary"`
	Embedding   pgvector_go.Vector `json:"embedding"`
	Metadata    []byte             `json:"metadata"`
	CreatedAt   pgtype.Timestamp   `json:"created_at"`
	UpdatedAt   pgtype.Timestamp   `json:"updated_at"`
	Similarity  int32              `json:"similarity"`
}

func (q *Queries) SearchArchitectureSummariesByEmbedding(ctx context.Context, arg SearchArchitectureSummariesByEmbeddingParams) ([]SearchArchitectureSummariesByEmbeddingRow, error) {
	rows, err := q.db.Query(ctx, searchArchitectureSummariesByEmbedding, arg.Column1, arg.SnapshotID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchArchitectureSummariesByEmbeddingRow{}
	for rows.Next() {
		var i SearchArchitectureSummariesByEmbeddingRow
		if err := rows.Scan(
			&i.ID,
			&i.SnapshotID,
			&i.SummaryType,
			&i.Summary,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertArchitectureSummary = `-- name: UpsertArchitectureSummary :one
INSERT INTO architecture_summaries (
    snapshot_id,
    summary_type,
    summary,
    embedding,
    metadata
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (snapshot_id, summary_type)
DO UPDATE SET
    summary = EXCLUDED.summary,
    embedding = EXCLUDED.embedding,
    metadata = EXCLUDED.metadata,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, snapshot_id, summary_type, summary, embedding, metadata, created_at, updated_at
`

type UpsertArchitectureSummaryParams struct {
	SnapshotID  pgtype.UUID        `json:"snapshot_id"`
	SummaryType string             `json:"summary_type"`
	Summary     string             `json:"summary"`
	Embedding   pgvector_go.Vector `json:"embedding"`
	Metadata    []byte             `json:"metadata"`
}

func (q *Queries) UpsertArchitectureSummary(ctx context.Context, arg UpsertArchitectureSummaryParams) (ArchitectureSummary, error) {
	row := q.db.QueryRow(ctx, upsertArchitectureSummary,
		arg.SnapshotID,
		arg.SummaryType,
		arg.Summary,
		arg.Embedding,
		arg.Metadata,
	)
	var i ArchitectureSummary
	err := row.Scan(
		&i.ID,
		&i.SnapshotID,
		&i.SummaryType,
		&i.Summary,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
